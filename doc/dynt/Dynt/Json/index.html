<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Json (dynt.Dynt.Json)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">dynt</a> &#x00BB; <a href="../index.html">Dynt</a> &#x00BB; Json</nav><h1>Module <code>Dynt.Json</code></h1><p>Json compatible representation of values.</p></header><section><header><h3 id="representation-of-json-trees"><a href="#representation-of-json-trees" class="anchor"></a>Representation of JSON trees</h3></header><dl><dt class="spec type" id="type-number"><a href="#type-number" class="anchor"></a><code><span class="keyword">type </span>number</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-number.I" class="anchored"><td class="def constructor"><a href="#type-number.I" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">I</span><span class="keyword"> of </span>int</code></td></tr><tr id="type-number.F" class="anchored"><td class="def constructor"><a href="#type-number.F" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">F</span><span class="keyword"> of </span>float</code></td></tr></table></dt><dt class="spec type" id="type-value"><a href="#type-value" class="anchor"></a><code><span class="keyword">type </span>value</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-value.Null" class="anchored"><td class="def constructor"><a href="#type-value.Null" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Null</span></code></td></tr><tr id="type-value.Bool" class="anchored"><td class="def constructor"><a href="#type-value.Bool" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Bool</span><span class="keyword"> of </span>bool</code></td></tr><tr id="type-value.Number" class="anchored"><td class="def constructor"><a href="#type-value.Number" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Number</span><span class="keyword"> of </span><a href="index.html#type-number">number</a></code></td></tr><tr id="type-value.String" class="anchored"><td class="def constructor"><a href="#type-value.String" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">String</span><span class="keyword"> of </span>string</code></td></tr><tr id="type-value.Array" class="anchored"><td class="def constructor"><a href="#type-value.Array" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Array</span><span class="keyword"> of </span><a href="index.html#type-value">value</a> list</code></td></tr><tr id="type-value.Object" class="anchored"><td class="def constructor"><a href="#type-value.Object" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Object</span><span class="keyword"> of </span>(string<span class="keyword"> * </span><a href="index.html#type-value">value</a>) list</code></td></tr></table></dt></dl><aside><p>Notes:</p><ul><li>The <code>String</code> payload is either Latin1-encoded or utf8-encoded, depending on the <code>utf8</code> flag passed to <code>encode/decode</code>. When not in utf8 mode, a code point outside the range of that character set will be encoded in a special (undocumented) way.</li></ul></aside></section><section><header><h3 id="mapping-between-json-trees-and-their-textual-representation."><a href="#mapping-between-json-trees-and-their-textual-representation." class="anchor"></a>Mapping between JSON trees and their textual representation.</h3></header><dl><dt class="spec value" id="val-encode"><a href="#val-encode" class="anchor"></a><code><span class="keyword">val </span>encode : ?&#8288;utf8:bool <span>&#45;&gt;</span> <a href="index.html#type-value">value</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Encode JSON tree into a compact JSON text (single line, etc).</p></dd></dl><dl><dt class="spec value" id="val-decode"><a href="#val-decode" class="anchor"></a><code><span class="keyword">val </span>decode : ?&#8288;utf8:bool <span>&#45;&gt;</span> ?&#8288;filename:string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-value">value</a></code></dt><dd><p>Parse a JSON text into JSON tree. Report parse errors using the <code>Failure</code> exception. The optional <code>filename</code> argument is used to report locations in error messages.</p></dd></dl><dl><dt class="spec value" id="val-to_pretty_string"><a href="#val-to_pretty_string" class="anchor"></a><code><span class="keyword">val </span>to_pretty_string : <a href="index.html#type-value">value</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Prints a JSON tree into human-friendly text (multi-line, indentation). The output is NOT a parsable json string.</p></dd></dl><dl><dt class="spec type" id="type-ctx"><a href="#type-ctx" class="anchor"></a><code><span class="keyword">type </span>ctx</code></dt><dd><p>Context storing serialization variations directives.</p><p>Variations:</p><ul><li>to_json_field: how to translate a json field name to an mlfi record field.</li></ul></dd></dl><dl><dt class="spec value" id="val-ctx"><a href="#val-ctx" class="anchor"></a><code><span class="keyword">val </span>ctx : ?&#8288;to_json_field:(string <span>&#45;&gt;</span> string) <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-ctx">ctx</a></code></dt></dl></section><section><header><h3 id="typeful-generic-mapping-between-json-trees-and-ocaml-values."><a href="#typeful-generic-mapping-between-json-trees-and-ocaml-values." class="anchor"></a>Typeful generic mapping between JSON trees and OCaml values.</h3></header><dl><dt class="spec value" id="val-to_json"><a href="#val-to_json" class="anchor"></a><code><span class="keyword">val </span>to_json : ?&#8288;ctx:<a href="index.html#type-ctx">ctx</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../Ttype/index.html#type-t">Ttype.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-value">value</a></code></dt><dd><p><code>to_json x</code> maps an OCaml value to a JSON tree representing the same information. The mapping is driven by the type of <code>x</code> and the default behavior (which can be overridden) is defined below.</p><p>Basic types:</p><pre><code class="ml">- 1          ---&gt; 1
- 1.         ---&gt; 1.
- ()         ---&gt; {}
- true/false ---&gt; true/false
- &quot;abc&quot;      ---&gt; &quot;abc&quot;
- 2001-01-01 ---&gt; &quot;2001-01-01&quot;</code></pre><p>List/array/tuple types:</p><pre><code class="ml">- [x; y]   ---&gt; [x', y']
- [|x; y|] ---&gt; [x', y']
- (x, y)   ---&gt; [x', y']</code></pre><p>Record types:</p><pre><code class="ml">- {l1 = x; l2 = y}    ---&gt; {&quot;l1&quot;: x', &quot;l2&quot;: y'}
- {l1 = x; l2 = None} ---&gt; {&quot;l1&quot;: x'}</code></pre><p>Sum types:</p><pre><code class="ml">- A                  ---&gt; {&quot;type&quot;: &quot;A&quot;}
- B x                ---&gt; {&quot;type&quot;: &quot;B&quot;, &quot;val&quot;: [x'] }
- C (x, y)           ---&gt; {&quot;type&quot;: &quot;C&quot;, &quot;val&quot;: [x', y'] }
- D {l1 = x; l2 = y} ---&gt; {&quot;type&quot;: &quot;D&quot;, &quot;l1&quot;: x', &quot;l2&quot;: y'}</code></pre><p>Option types:</p><pre><code class="ml">- Some x ---&gt; x'
- None   ---&gt; null (when not in record)</code></pre><p>Nested option types!</p><pre><code class="ml">- Some (Some x) ---&gt; {&quot;type&quot;: &quot;Some&quot;, &quot;val&quot;: x'}
- Some None     ---&gt; {&quot;type&quot;: &quot;Some&quot;}
- None          ---&gt; {&quot;type&quot;: &quot;None&quot;}</code></pre><p>Lazy types:</p><pre><code class="ml">- lazy x ---&gt; x'
  (x is forced upon jsonification; de-jsonification is lazy)</code></pre><p>String Maps ('a Mlfi_sets_maps.StringMap.t) are mapped to objects, e.g.</p><pre><code class="ml">- {&quot;a&quot; -&gt; 1; &quot;b&quot; -&gt; 2}                 ---&gt; {&quot;a&quot;: 1, &quot;b&quot;: 2}
- {&quot;foo&quot; -&gt; &quot;hello&quot;; &quot;bar&quot; -&gt; &quot;world&quot;} ---&gt; {&quot;foo&quot;: &quot;hello&quot;, &quot;bar&quot;: &quot;world&quot;}</code></pre><p>Special cases:</p><pre><code class="ml">- (x : Variant.t)  ----&gt;  &lt;textual representation of x, in OCaml syntax&gt;
- (x : Json.value) ----&gt;  x</code></pre><p>Notes:</p><ul><li>Function types and object types are not supported.</li></ul><ul><li>Upon parsing, extra fields in objects are accepted and ignored (including when parsing a sum type or unit).</li></ul><ul><li>Special float values (nan, infinity) are not supported (but not explicitly checked).</li></ul><ul><li>TODO?: special case when all constructors are empty (mapped to strings).</li></ul><ul><li>TODO: support some type properties (default value, etc).</li></ul></dd></dl><dl><dt class="spec value" id="val-of_json"><a href="#val-of_json" class="anchor"></a><code><span class="keyword">val </span>of_json : ?&#8288;ctx:<a href="index.html#type-ctx">ctx</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../Ttype/index.html#type-t">Ttype.t</a> <span>&#45;&gt;</span> <a href="index.html#type-value">value</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Reverse mapping. If <code>to_json ~t x</code> succeeds, the property <code>of_json ~t (to_json ~t x) = x</code> is expected to hold (except corner cases such as unchecked special float values, and assuming that custom converters behaves properly).</p></dd></dl><dl><dt class="spec type" id="type-custom_json"><a href="#type-custom_json" class="anchor"></a><code><span class="keyword">type </span>'a custom_json</code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-custom_json.to_json" class="anchored"><td class="def field"><a href="#type-custom_json.to_json" class="anchor"></a><code>to_json : <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-value">value</a>;</code></td></tr><tr id="type-custom_json.of_json" class="anchored"><td class="def field"><a href="#type-custom_json.of_json" class="anchor"></a><code>of_json : <a href="index.html#type-value">value</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>;</code></td></tr></table><code>}</code></dt></dl></section><section><header><h3 id="custom-mapping-for-specific-types"><a href="#custom-mapping-for-specific-types" class="anchor"></a>Custom mapping for specific types</h3></header><dl><dt class="spec value" id="val-register_custom"><a href="#val-register_custom" class="anchor"></a><code><span class="keyword">val </span>register_custom : t:<span class="type-var">'a</span> <a href="../Ttype/index.html#type-t">Ttype.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-custom_json">custom_json</a> <span>&#45;&gt;</span> unit</code></dt></dl><aside><p><code>register_conversion</code> registers a global custom mapping between OCaml values and JSON trees for a specific closed *abstract* type.</p><p>TODO: Bring this documentation up to date. Especially, we support non-abstract things now.</p><p>It is not allowed to use <code>null</code> in the JSON representation of values, at least if the type is used under the option type constructor (<code>null</code> is reserved for representing the <code>None</code> case).</p></aside><div class="spec module" id="module-Matcher"><a href="#module-Matcher" class="anchor"></a><code><span class="keyword">module </span><a href="Matcher/index.html">Matcher</a> : <a href="../Matcher/index.html#module-type-S">Matcher.S</a><span class="keyword"> with </span><span class="keyword">type </span>'a <a href="../Matcher/module-type-S/index.html#type-data">data</a> := <span class="type-var">'a</span> <a href="index.html#type-custom_json">custom_json</a></code></div><dl><dt class="spec value" id="val-register_custom_0"><a href="#val-register_custom_0" class="anchor"></a><code><span class="keyword">val </span>register_custom_0 : (<span class="keyword">module </span><a href="Matcher/module-type-C0/index.html">Matcher.C0</a>) <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-register_custom_1"><a href="#val-register_custom_1" class="anchor"></a><code><span class="keyword">val </span>register_custom_1 : (<span class="keyword">module </span><a href="Matcher/module-type-C1/index.html">Matcher.C1</a>) <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-register_custom_2"><a href="#val-register_custom_2" class="anchor"></a><code><span class="keyword">val </span>register_custom_2 : (<span class="keyword">module </span><a href="Matcher/module-type-C2/index.html">Matcher.C2</a>) <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-of_get_params"><a href="#val-of_get_params" class="anchor"></a><code><span class="keyword">val </span>of_get_params : ?&#8288;utf8:bool <span>&#45;&gt;</span> (string<span class="keyword"> * </span>string) list <span>&#45;&gt;</span> <a href="index.html#type-value">value</a></code></dt><dt class="spec value" id="val-to_get_params"><a href="#val-to_get_params" class="anchor"></a><code><span class="keyword">val </span>to_get_params : ?&#8288;utf8:bool <span>&#45;&gt;</span> <a href="index.html#type-value">value</a> <span>&#45;&gt;</span> (string<span class="keyword"> * </span>string) list</code></dt></dl><div class="spec module" id="module-Access"><a href="#module-Access" class="anchor"></a><code><span class="keyword">module </span><a href="Access/index.html">Access</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></div></body></html>